module ex9_top(CLOCK_50,KEY,LEDR,HEX0,HEX1,HEX2,HEX4,HEX5);

	input CLOCK_50;
	input [3:3] KEY;


	output [9:0] LEDR;
	output [6:0] HEX0,HEX1,HEX2,HEX5,HEX4;

// ---- submodule interface

	wire tick_ms;//every 1ms 
	wire tick_hs;//every 0.5s
	
	reg time_out;//is 1 if countdown finish
	
	reg en_lfsr;//enable LFSR
	reg [7:1] rand;//random number generated by LFSR
	reg [6:0] displayrand;
	
	reg start_delay;//start delay

	
	clkdiv_16 div50000 (CLOCK_50,tick_ms,16'd50000);
	clkdiv_16 div500 (tick_ms,tick_hs,16'd500);
	
// ---- submodule FSM
	//use MSB to control if 7seg are on
	parameter OFF=3'b000;
	parameter LIGHTUP=3'b001;
	parameter WAITDELAY=3'b010;
	parameter CHEATING_PREVENTION=3'b011;
	parameter REACTION=3'b100;
	parameter IDEL=3'b101;

	
	reg[2:0] state;
	initial state=2'b0;

	reg [9:0] ledbuff;
	
	always @ (posedge tick_ms) begin : FSM
		case (state)
			OFF: if (~KEY[3]) state<=LIGHTUP;
				else begin
					ledbuff<=10'b0;
					start_delay<=1'b0;
					en_lfsr<=1'b0;
					enableUp<=1'b0;
				end
			LIGHTUP: if (ledbuff[0]==1'b1) begin state<=WAITDELAY; start_delay<=1'b1; end
				else begin
					if (tick_hs)
						ledbuff<={1'b1,ledbuff[9:1]};
					
					en_lfsr<=1'b1;
				end
			WAITDELAY: if (time_out==1'b1) state<=CHEATING_PREVENTION;
				else begin
					start_delay<=1'b1;
					en_lfsr<=1'b0;
					resetUp<=1'b1;
					enableUp<=1'b0;
				end
			CHEATING_PREVENTION:begin 
				enableUp<=1'b1;
				resetUp<=1'b0;
				ledbuff<=10'b0;
				if (KEY[3]) state<=REACTION;
			end
			REACTION: if(~KEY[3]) begin state<=IDEL; enableUp<=1'b0;resetUp<=1'b0; end
			else enableUp<=1'b1;
			IDEL: if(KEY[3]) state<=OFF; 
			
			
				
					
		endcase
	end

// ---- end FSM


// ---- submodule LFSR
	initial rand=7'b1;
	
	always @ (posedge tick_ms) begin : LFSR
		if (en_lfsr)
			rand<={rand[6:1],rand[1]^rand[7]};
	end
	
// ---- end LFSR


// ---- submodule delay counter
	reg [13:0] countdown;
	reg counter_running;

	
	always @ (posedge tick_ms)
		if (start_delay)
			if(countdown==14'b0)
				time_out<=1'b1;
			else begin
				countdown=countdown-14'b1;
				time_out<=1'b0;
			end
		else begin
			time_out<=1'b0;
			countdown<={rand[7:1],7'd250};
			displayrand<=rand[7:1];
		end
// ---- end submodule


// ---- submodule led
		assign LEDR=ledbuff;

// ---- end submodule

// ---- submodule hexdisplay
	wire [3:0] bcd0,bcd1,bcd2,bcd3,bcd4;
	wire [6:0] s0,s1,s2,s3,s4,s5;

	wire [19:0] segbus;
	
	bin2bcd_16 B2B (countup , bcd0, bcd1, bcd2, bcd3, bcd4);
	hex_2_7seg SEG0 (.in(bcd0),.out(s0));
	hex_2_7seg SEG1 (.in(bcd1),.out(s1));
	hex_2_7seg SEG2 (.in(bcd2),.out(s2));
	hex_2_7seg SEG3 (.in(bcd3),.out(s3));
	hex_2_7seg SEG4 (.in(bcd4),.out(s4));
	
	
	assign HEX0=(state==OFF)? s0 : 7'h7F;
	assign HEX1=(state==OFF)? s1 : 7'h7F;
	assign HEX2=(state==OFF)? s2 : 7'h7F;
	assign HEX4=(state==OFF)? s3 : 7'h7F;
	assign HEX5=(state==OFF)? s4 : 7'h7F;
	
// ---- end submodule

// ---- submidule counter
	reg [15:0] countup;
	initial countup=16'b0;
	reg enableUp;
	reg resetUp;
	
	always @ (posedge tick_ms)
		if(resetUp==1'b1)
			countup<=16'b0;
		else if(enableUp==1'b1)
			countup<=countup+16'b1;
		else
			countup<=countup;

// ---- end submodule


endmodule
